#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function
import scipy.io.wavfile as wavfile
import scipy
import scipy.signal
import scipy.fftpack
import numpy as np
from matplotlib import pyplot as plt
import math
import re
import sys

MARKER_FREQ = 1325.0 # Hz
MARKER_LEN = 0.050	# seconds

ROUGH_RESOLUTION = 100.0 # Hz
PERIOD_TRIM = 0.1 # seconds

TEST_PERIOD = 10.0 # seconds

FUDGE_ALLOWANCE = 0.1

CALC_RESOLUTION  = 5.0 # Hz

class TapeTest:
	def __init__(self, filename):
		self.ifile = filename
		self.ofile = re.sub(r'wav$', 'csv', filename)
		pass

	# Load the input file and initial sample constants, mix down to one channel
	def load_input(self):
		sample_freq, signal = wavfile.read(self.ifile)

		self.fs = float(sample_freq)
		self.Ts = 1.0 / self.fs
		self.signal = mixdown(signal)

		print('Loaded', len(self.signal), 'samples')

	def spectro_sn(self, signal, f_bin, f0, bandwidth, **kwargs):
		fft_size = iround(self.fs / f_bin)
		max_deviation = float(bandwidth) / 2.0

		fs, ts, spectro = scipy.signal.spectrogram(signal, self.fs, nperseg = fft_size, window = 'hamming', mode = 'psd')
		buckets = [i for i, f in enumerate(fs) if abs(f - f0) <= max_deviation]

		print("Spectrogram scan for", round(f0, 2), "Hz using FFT size", fft_size, "across", len(buckets), "bins")

		signal_powers = spectro[buckets, :].sum(axis = 0)
		total_powers = spectro.sum(axis = 0)

		noise_powers = total_powers - signal_powers
		return ts, signal_powers, noise_powers

	def welch(self, signal, f_bin):
		fft_size = iround(self.fs / f_bin)
		return scipy.signal.welch(signal, fs = self.fs, nperseg = fft_size, window = 'hamming')

	def detect_markers(self):
		ts, signal_powers, noise_powers = self.spectro_sn(
			self.signal, ROUGH_RESOLUTION, MARKER_FREQ, 2 * ROUGH_RESOLUTION
		)

		was_marker = False
		sum_signal = 0.0
		sum_noise = 0.0
		self.markers = []
		self.periods = []
		start = None

		for i, signal in enumerate(signal_powers):
			t = ts[i]
			# total = total_powers[i]
			noise = noise_powers[i] #total - signal
			snr = signal / noise

			is_marker = snr > 1.0
			if is_marker and not was_marker:
				if start != None:
					period = (start + PERIOD_TRIM, t - PERIOD_TRIM)
					self.periods.append(period)
					print("Period",
							round(period[0], 3), "to", round(period[1], 3))
				start = t
				sum_signal = signal
				sum_noise = noise
			elif is_marker:
				sum_signal += signal
				sum_noise += noise
			elif was_marker:
				marker = (start, t, sum_signal / sum_noise)
				self.markers.append(marker)
				print("Marker",
						round(marker[0], 3), "to", round(marker[1], 3),
						"SNR", dB(marker[2], places = 2), "dB")
				start = t
			was_marker = is_marker

	def check_calibration(self):
		assert(len(self.markers) == 10)
		assert(len(self.periods) == 9)
		for p in self.periods:
			p_len = p[1] - p[0]
			assert(abs(TEST_PERIOD - p_len) < TEST_PERIOD * FUDGE_ALLOWANCE)

	def run_all_tests(self):
		tests = [
			self.test_noise_floor,
			self.test_signal_level,
			self.test_freq_response #,
			#self.test_thd,
			#self.test_imd,
			#self.test_ampl_linearity,
			#self.test_square_shape,
			#self.test_saw_shape,
			#self.test_timing
		]
		for i, testMethod in enumerate(tests):
			data = self.get_period_data(i)
			testMethod(data)

	def get_period_data(self, period):
		start, end = self.periods[period]
		sample_range = range(iround(start * self.fs), iround(end * self.fs))
		return self.signal[sample_range]

	def test_noise_floor(self, signal):
		avg_power = np.var(signal)
		self.noise_floor_power = avg_power
		print("Noise floor", dB(avg_power, places = 2), "dB1")

	def test_signal_level(self, signal):
		ts, signal_powers, noise_powers = self.spectro_sn(
			signal, CALC_RESOLUTION, 1000, 50
		)

		snrs = signal_powers / noise_powers
		best_snr = snrs.max()
		i = [i for i, snr in enumerate(snrs) if snr == best_snr][0]
		print("Best SNR", dB(best_snr, places = 2), "dB at", round(ts[i], 3))

		power_range = range(iround(i - self.fs), i) # 1 second
		avg_power = np.var(signal[power_range])
		self.best_level = avg_power - self.noise_floor_power
		print("Best level", dB(avg_power, places = 2), "dB1")
		print("Level to noise floor", dB(self.best_level / self.noise_floor_power, places = 2), "dB")

	def test_freq_response(self, signal):
		fs, spectrum = self.welch(signal, 100)
		n = len(fs) - 1

		bucket_1khz = np.argmin([abs(f - 1000.0) for f in fs ])
		p_1khz = spectrum[bucket_1khz]
		p_3db = p_1khz / 2.0

		bucket_l = safe(max, [i for i, p in enumerate(spectrum) if i < bucket_1khz and p < p_3db]) or 0
		f_l = fs[bucket_l + 1]

		bucket_h = safe(min, [i for i, p in enumerate(spectrum) if i > bucket_1khz and p < p_3db]) or n
		f_h = fs[bucket_h - 1]

		print("Detected usable bandwidth", f_l, "-", f_h, "Hz")

		passband = range(2 * (1 + bucket_l), bucket_h // 2)
		max_deviation = max([dB(p / p_1khz, 2) for i, p in enumerate(spectrum) if i in passband], key = abs)

		print([dB(p / p_1khz, 2) for i, p in enumerate(spectrum) if i in passband])

		print("Approximate Flatness", max_deviation, "dB")

		# Estimate flatness of passband

	def test_thd(self, signal):
		pass
		# Use welch's method to FFT over the whole segment
		# Sum bins for f = 1000
		# Sum bins for f = N * 1000 N > 1
		# Divide out

## Utility functions follow ##

# max / min but return None if there are no elements
def safe(func, list, **kwargs):
	if len(list) == 0:
		return None
	return func(list, **kwargs)

# Express a ratio in dB
def dB(n, places = None):
	db = 10 * np.log10(n)
	if places:
		return round(db, places)
	return db

# Round to an int
def iround(n):
	return int(round(n))

# Mix a signal down
def mixdown(signal):
	n_dimensions = len(signal.shape)
	if n_dimensions == 1:
		return signal

	n_channels = signal.shape[1]
	return signal.sum(axis=1) / n_channels

def main():
	t = TapeTest(sys.argv[1])
	t.load_input()
	# t.rough_out()
	t.detect_markers()
	t.check_calibration()
	t.run_all_tests()

if __name__ == "__main__":
	main()
